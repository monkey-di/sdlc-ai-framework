Технический отчет: Методология автоматизированной генерации адаптивных интерфейсов на Tailwind CSS с использованием Gemini CLI и протокола MCP для FigmaАннотацияВ данном отчете представлен исчерпывающий анализ и практическое руководство по использованию интерфейса командной строки Gemini (Gemini CLI) в связке с протоколом контекста модели (Model Context Protocol — MCP) для автоматизации верстки веб-интерфейсов. Основное внимание уделено трансформации дизайн-макетов из Figma в семантический, адаптивный код на базе фреймворка Tailwind CSS с точностью уровня «pixel perfect». Документ подробно рассматривает архитектуру взаимодействия между LLM (большими языковыми моделями) и графическим редактором, анализирует структуру данных Figma API и предлагает оптимизированные алгоритмы промпт-инжиниринга для минимизации времени разработки.Версия документа 2.0: Добавлены стратегии для сценариев Brownfield (работа с легаси), Dual-Frame (слияние мобильного и десктопного макетов) и Pure HTML.1. Введение: Смена парадигмы в разработке интерфейсовИндустрия веб-разработки находится в точке бифуркации, обусловленной появлением протоколов, стандартизирующих обмен контекстом между инструментами разработки и генеративными моделями искусственного интеллекта. Традиционный процесс передачи макетов от дизайнера к разработчику (handoff) исторически сопровождался потерей данных: семантика, заложенная в дизайн-систему, часто утрачивалась при ручном переносе визуальных параметров в CSS-свойства.Появление Model Context Protocol (MCP) и его интеграция в экосистему Figma через Gemini CLI меняет фундаментальный подход к верстке. Вместо визуальной имитации макета, AI-агент теперь получает доступ к исходному коду дизайна — структурированному дереву узлов (Node Graph), описывающему геометрию, стилистику и логику ограничений (Constraints).1 Это позволяет перейти от императивного написания стилей к декларативному запросу намерений.2. Архитектура интеграции: MCP, Gemini и FigmaДля достижения максимальной скорости и качества генерации кода необходимо детальное понимание инфраструктуры.2.1 Протокол контекста модели (MCP)Model Context Protocol (MCP) — это открытый стандарт для подключения AI-моделей к внешним данным. В нашей задаче он выступает переводчиком, преобразующим структуры данных Figma в формат, понятный Gemini.3MCP Host (Gemini CLI): Исполняющая среда.MCP Server (Figma Server): Абстрагирует Figma API, предоставляя инструменты (get_design_context, get_variable_defs).52.2 Ключевые инструменты сервера Figma MCPПонимание инструментов критично для написания промптов:get_design_context: Возвращает структуру узла (Layout, стили, типографика). Это основной источник для HTML-структуры.6get_variable_defs: Извлекает дизайн-токены. Критически важен для маппинга цветов (напр., bg-primary вместо hex-кода).7get_screenshot: Генерирует растровое изображение для визуальной проверки моделью.83. Физика трансляции: От Figma к Tailwind CSS3.1 Маппинг Auto Layout в FlexboxСвойство FigmaЭквивалент TailwindНюансlayoutMode: HORIZONTALflex flex-rowТребует явного указания направления.9primaryAxisAlignItems: SPACE_BETWEENjustify-betweenРаботает только если ширина контейнера не w-fit.10itemSpacing: 16gap-4Требуется конвертация px -> rem (деление на 4).11layoutSizing: FILLflex-1 / w-fullЗависит от контекста родителя.123.2 Проблема адаптивности (Dual-Frame Challenge)В реальных условиях дизайнеры часто предоставляют два разных фрейма: Mobile (375px) и Desktop (1440px). Прямая генерация кода из одного фрейма не даст адаптивности.Решение: Стратегия последовательного слияния (Sequential Merge). Сначала генерируется база из мобильного макета (Mobile-First), затем код подается обратно в контекст модели вместе с десктопным макетом для вычисления «дельты» и добавления префиксов md: и lg:.4. Стратегия промпт-инжинирингаДля качественного результата мы используем методологию «Архитектор», разделяющую процесс на фазы анализа, генерации каркаса и стилизации.5. Репозиторий промптов (Prompt Library)Ниже представлены готовые сценарии. Скопируйте нужный блок в Gemini CLI.5.1 Контекстный Мастер-промпт (System Initialization)Вводите этот промпт в начале сессии, чтобы настроить агента. Замените [СТЕК] на нужный (например, "Pure HTML + Tailwind" или "React + Tailwind").«Действуй как Senior Frontend Engineer. Твоя задача — транслировать данные из Figma MCP в код, строго следуя принципу "Pixel Perfect" относительно дизайн-токенов и отступов.Настройки стека:Стек: [СТЕК]Твои инструменты:get_design_context: Для получения структуры узлов.get_variable_defs: Для маппинга hex-кодов в имена переменных (например, bg-slate-900).read_file / write_file: Для работы с локальным кодом (Brownfield сценарии).Критические правила трансляции:Auto Layout -> Flexbox: HORIZONTAL = flex-row, VERTICAL = flex-col.Rem-шкала: Все пиксельные значения (отступы, шрифты, размеры) дели на 4. Пример: 24px -> p-6.Игнорирование фиксации: Для корневых контейнеров запрещено использовать w-[1440px]. Используй w-full max-w-screen-xl mx-auto.Mobile First: Генерируй базовые классы для мобильной версии. Десктопные переопределения добавляй через префикс md: или lg:.»5.2 Сценарий А: «Dual-Frame Merging» (Мобильный + Десктоп)Используйте этот сценарий, когда дизайнер предоставил два отдельных макета. Этот метод предотвращает "кашу" в коде и переполнение контекста.Шаг 1: Генерация базы (Mobile)Выделите мобильный фрейм в Figma.«Я выбрал мобильный макет (Mobile Frame).Проанализируй его структуру через get_design_context.Сверстай HTML-структуру (или компонент), используя только базовые классы Tailwind (без префиксов sm:, md:).Убедись, что все элементы идут в вертикальном потоке (flex-col), где это необходимо.Если встретишь сложные элементы (аккордеоны, слайдеры), просто пометь их комментариями ``.Выведи только код.»Шаг 2: Десктопная адаптация (Desktop Merge)Не очищая контекст диалога, выделите десктопный фрейм в Figma.«Теперь я выбрал десктопный макет (Desktop Frame) того же блока.Твоя задача — обновить ранее сгенерированный код, добавив адаптивность.Алгоритм действий:Сравни структуру десктопа с мобильной версией.Найди контейнеры, которые меняют направление (например, были flex-col, стали flex-row). Добавь к ним класс md:flex-row.Найди элементы, которые скрыты на мобильном, но есть на десктопе. Добавь им hidden md:block.Обнови размеры шрифтов и отступы, используя префикс md: (например, text-sm md:text-lg).Важно: Не дублируй HTML. Используй одни и те же теги с разными классами. Если структура DOM радикально отличается (например, Табы вместо Аккордеона), напиши: <div className="hidden md:block">...Tabs...</div> и скрой мобильную версию через md:hidden.Выведи итоговый, объединенный адаптивный код.»5.3 Сценарий Б: «Brownfield» (Рефакторинг существующего кода)Для ситуаций, когда файл уже существует, но верстка "поехала" или устарела.«Я хочу обновить существующий файл [ПУТЬ_К_ФАЙЛУ], чтобы он соответствовал выбранному макету в Figma.Инструкция:Сначала прочитай текущий код файла с помощью read_file.Затем запроси данные из Figma для текущего выделения (get_design_context + get_variable_defs).Сравни и обнови:Сохрани существующую JS-логику, импорты и обработчики событий (onClick и т.д.). Не удаляй их!Полностью перепиши классы className="..." в HTML/JSX, чтобы они соответствовали отступам, цветам и типографике из Figma.Если в Figma появились новые элементы, аккуратно добавь их в структуру.Если какие-то элементы удалены в дизайне, удали их из кода.Используй write_file (если у тебя есть права) или выведи полный код файла для копирования.»5.4 Сценарий В: Чистый HTML (No-Code Frameworks / Legacy)Промпт для получения "чистой" верстки без JSX, React.Fragment и прочего.«Сгенерируй чистый HTML5 код для выбранного элемента.Требования:Никакого React, Vue или JSX.Используй семантические теги: <section>, <article>, <button type="button">.SVG иконки вставляй инлайном или используй <img> плейсхолдеры.Не используй className, используй class (стандартный HTML атрибут).Если нужны интерактивные состояния (ховеры), используй классы Tailwind hover:bg-... и group-hover:....Весь CSS должен быть только утилитарными классами Tailwind.»5.5 Промпт для Визуального QA (Проверка расхождений)Этот промпт полезен для финальной проверки, когда Gemini сравнивает свой результат с картинкой.«Сделай скриншот текущего выделения в Figma (get_screenshot).Внимательно посмотри на изображение и на код, который ты сгенерировал.Найди 3 визуальных отличия, которые бросаются в глаза (например, "тень слишком мягкая", "кнопка недостаточно скруглена", "отступы в коде меньше, чем на макете").Предложи исправленный список классов Tailwind для устранения этих различий.»6. ЗаключениеИспользование Gemini CLI с доступом к Figma MCP трансформирует процесс верстки из рутинного переноса свойств в инженерное управление генерацией. Ключ к «идеальной» верстке лежит не в способности модели угадывать, а в способности разработчика четко сформулировать правила трансляции данных Figma в семантику Tailwind.Представленные промпты решают главную проблему автоматической генерации — отсутствие контекста о поведении интерфейса. Навязывая модели логику mobile-first, приоритет токенов над значениями и понимание механики Auto Layout, мы получаем код, который не требует полного переписывания, а готов к внедрению в продакшн.